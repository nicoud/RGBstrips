{
    "docs": [
        {
            "location": "/", 
            "text": "Smart RGB LED strips\n\n\nOriginal document by \nDidel\n.\n\n\n\n\nThere is now a big choice of strips of colored leds. They are supported by libraries for Arduino, Raspberry and ESP8266.\n\n\nWe are interested here about the functionality of chips from different makers and how to write the required low level control routines.\n\n\nSPI 2-control lines  0 \u2013 20 MHz\n\n\nWS2801\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis 14-pin circuit includes three 8-bit PWM . Easy to program, as shown later. Can be used with any leds and any resistor value. Ck/Data serial transfer.\n\n\n\n\nThe LPD8806/LPD6806 is similar but desappeared from the market. Transfer was three 5-bit PWM (16-bit words).\n\n\nAPA102C and SK9822\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe APA102C and Sk9822 have SPI-like transfer, no timing constraint. New there is also a miniature APA102C-2020.\nThe APA102C is an additional control register v that sets the brightness of every pixel, independently of its color.\nAPA102 has 20 kHz PWM,  SK9822 1.2 kHz:\n\n\n\n\n1-wire control   800 or 580 kHz\n\n\n(timings see here)\n\n\nWS2812b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe WS2812 (not shown) was the first RGB 5050 package with the microcontroller inside. 6-pin package replaced by WS2812b\n\n\nThe WS2812b is controlled by one wire with a critical timing that needs bit-banging routines on 16MHz AVR.\n\n\n\n\nAPA104\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe APA104 has a slightly different timing than the WS2812B, but can be compatible. A 50us delay terminates the shift-in.\n\n\n\n\nAPA106\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe  APA106 is the through-hole LED version of the APA104.\n\n\n\n\n\n\n\n\nSK6812\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe SK6812 receives 24 bit words. Transfer speed is 800 kHz.\n\n\n\n\nA word about serial transfers\n\n\n\n\nShift registers are used to convert a stream of bits synchronized by a clock into parallel data.\nA parallel register keeps the previous data during the shift and is updated at the end of the transfer.\nThis is the principle of the SPI transfer. Registers can be cascaded.\n\n\n\n\nA popular application for this is to control LEDs. Several manufacturers propose shift registers with constant current sources at the outputs. A single resistor sets the current, same for all LEDs.\nPWM can be done on every LED. See \nhttp://www.didel.com/diduino/CommandeLeds.pdf \n for an elegant solution updating PWM while shifting.\n\n\nWS2801 as example of the inside logic\n\n\nThe WS2801 includes a 24 bit shift register with three 8-bit PWM controllers. Three LEDs are controlled by the circuit, usually a RGB SMD LED in a 5050 package. Intensity of LEDs is controlled by a resistor, constant current circuitry makes the intensity independant of the voltage (with 3-5V range).\n\n\n\n\nThe block diagram show something new. Data is not shifted through the complete serially connected circuits. The first 24 bits stay in the first circuit. When 24 clocks are counted, a switch transfers the clock to the output. Since there is no load line to transfer the shifted data to the PWM circuit, a one-shot circuit is activated when there is no clock for more than 1 ms. The signals are regenerated, allowing long strips, but adding a delay.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs said before, each circuit takes the first set of clocks and data he receives for himself, not transmitting that information further. The next clocks and data are amplified and transmitted. The delay introduced between each LED may be noticed over very long strips. The APA102C implement an additional trick to make the transmission reliable. It results in a strange formula, incorrect and not explained for the terminating frame. Not easy to well understant if you have not been educated with integrated circuit logic. Let us try!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the correct operation of a shift register, the flipflops must have the data stable when the clock edge occurs. set-up and hold time is 5 to 20 ns depending on the technology.The output D' changes after e.g. 20ns, and this must match the set-up time of the next flip-flop. One needs to add output buffers that introduce their own delay, plus the delay of the line. Depending on the difference between the clock and data propagation time, the transfer may not work correctly. \nOne solution is to increase the delay on the data line. This was probably done on the WS2801. It is more reliable to add a flip-flop on the data output, that add a delay of half a clock. This was implemented in the 1970' CD4094 8-bit shift register and is used on the APA102 and SK98. \nThe main advantage is the very high transfer speed it permits.\n\n\n\n\n\n\n\n\n\n\n\n\nDue to the mechanism that allows to access the pixels in the order they have been sent, and not as if it was a simple shift register, data is delayed by half a clock for each consecutive pixel. The last bit sent for the last pixel must be pushed half a clock at a time till its destination.\n\n\nColor control\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther chips have also 8-bit PWM, with a color order that may differ.\n\n\nRGB LEDs technology\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscrete LED chips are soldered inside 5050 packages. It is not well documented what are the specifications and how the difference of LED intensity is compensated. In the best case, the information is: \nRed\n620-625nm\n390-420mcd\n2.0-2.2V\nGreen\n522-525nm\n660-720mcd\n3.0-3.4V\nRed\n465-467nm\n180-200mcd\n3.0-3.4V\n\n\n\n\n\n\n\n\nRGB vs HSV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRGB is not adequate for mixing colors. Using a \"rainbow\" variable (called hue) that goes through the rainbow colors is obtained from mixing RGB, as with the rather simple algorithm next from \nthis reference\n we have reprogrammed in C (see appendix). \nThe \nhue H\n has a usually a 0-360 value due to its cylindrical representation. 0-255 is more convenient. \nThe \nsaturation S\n says how the image is \"rich\" vs \"pale\" and will be kept at its maximum of 255. \nThe \nvalue V\n is the brightness 0-255.\n\n\n\n\n\n\n\n\nEncoding colors is a rich and complex field. It is well described \nhere\n.\n\n\nNote on luminosity\n\n\nPWM is linear, 0 to 255. Our eye is not linear. 30% of PWM already feels as full light. \nNot convinced? Program intensity 0,16, 32\u2026 with a change every 0.2 seconds. The first steps are visible, not the last 5.\nThis means 16 or 32 intensity values are enough if converted to exponential values. \n\n\nuint8_t talum[16] = {  0,5,11,18, 26,35,44,54, 64,76,90,110, 135,170,210,255};\n\n\nProgramming existing strips\n\n\nWe are not concerned here about commercial products and their associated libraries.\nWe document how to program from the low level up, using simple portable C. Understanding how to initialize a port is the only requirement to use our libraries.\n\n\nWS2801/APA102C software\n\n\nThese curcuits have a SPI-like transfer over 2-control lines. The max clock speed for the \nWS2801 and APA102C is 20 MHz and data set-up time is 30 ns. The order for the WS2801 depends on the wiring between the 14-pin circuit and the RGB LED.\nThe WS2801 restarts when there is no clock for 1ms. It is not documented if the transfer to the output latches is made when the register is filled or at restart.\n\n\nThe APA102 and SK9822 need a start frame of 32 clocks with null data. Then, for every pixel, 4 bytes in the order - intensity, blue, green, red. Finally, additional clocks are given as explained before. \nNo clock for 1ms transfers the data to the LED register, hence minimal clock rate is 1kHz, interrupts must be less than 1ms.\nAVR SPI can be used, with Ck on pin 13 and Data on pin 11. SS pin is not used, but that pin must be initialised as an output otherwise transmission does not happen. Byte transfer is 2us.\nShifting data out by software is slower (7us per byte) but any pin can be used. Using the shiftOut() Arduino function is no sense (slow and not easier).\n\n\nThese are two possible implementations of the Snd8() function.\n\n\nExample 1:\n\n\n//Spi.h\n#define bDa  3   // MOSI 11 only here\n#define bCk  5   // pin 13\n#define bLd  2   // SS pin 10 \n#define SpiControl 0b01010000\n// SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0\nvoid SetupSPI ()  {\n  DDRB |=  1\nbCk | 1\nbDa | 1\nbLd ;\n  SPCR = SpiControl ;\n}\nvoid Snd8 (byte dd) {\n  SPDR = dd;\n  while (!(SPSR \n 1\nSPIF)) {}\n}\n\n\n\n\nExample 2:\n\n\n\n//S2.h\n#define bCk  14 //PORTC\n#define bDa  15 \n#define DaOn  bitSet(PORTC,bDa)\n#define DaOff bitClear(PORTC,bDa)\n#define ClkPulse bitSet(PORTC,bDa); \\\n                 bitClear(PORTC,bDa)\nvoid SetupS2 () {\n  DDRC |= (1\nbCk)+(1\nbDa)\n}\nvoid Snd8 (byte dd) {\n  for (byte i=0;i\n8;i++) {\n    if (dd \n 0x80) DaOn;\n    else DaOff; \n    CkPulse;   \n  }\n}\n\n\n\n\nNote:\n If \nbyte\n, \nbitSet\n, \nbitClear\n is not accepted, add the line \n#include\nArduino.h\n.\n\n\nIn case of the APA102C, the requested transfer order is easily converted to a function. Pixel values can frequently be calculated during the transfer. If the pixel array is in a table, function is:\n\n\nvoid SndRGB (byte n) {\n    Snd8(0x00); Snd8(0x00); Snd8(0x00); Snd8(0x00);\n    for (byte i=0;i\nNN;i++)  { Snd8(aa[i]); Snd8(gg[i]); Snd8(bb[i]); Snd8(rr[i]); }\n    for (byte i=0; i\n(NN+1)/2; i++) {CkOn; CkOff;} delay (10);\n}\n\n\n\n\nIf you give the correct number of clock pulses, only the declared LEDs will be activated.\n\n\nSee \nhttps://github.com/nicoud/RgbLeds\n for downloading the code.\n\n\nYou can find useful information on the APA102C on \nhttps://www.pololu.com/product/2554\n with comments on APA102C vs SK6812.\n\n\n1-wire smart LEDs\n\n\nSaving one wire is not a real advantage, since it is slower and less reliable both on hardware and software side. These circuits have critical timing need need bit-banging assembler code or macros. Interrupts must be disables during transfers. \n\n\n\n\n\n\n$Id: index.md,v 1.2 2017-01-03 15:02:22 obiwan Exp $", 
            "title": "Home"
        }, 
        {
            "location": "/#smart-rgb-led-strips", 
            "text": "Original document by  Didel .   There is now a big choice of strips of colored leds. They are supported by libraries for Arduino, Raspberry and ESP8266.  We are interested here about the functionality of chips from different makers and how to write the required low level control routines.", 
            "title": "Smart RGB LED strips"
        }, 
        {
            "location": "/#spi-2-control-lines-0-20-mhz", 
            "text": "", 
            "title": "SPI 2-control lines  0 \u2013 20 MHz"
        }, 
        {
            "location": "/#ws2801", 
            "text": "This 14-pin circuit includes three 8-bit PWM . Easy to program, as shown later. Can be used with any leds and any resistor value. Ck/Data serial transfer.   The LPD8806/LPD6806 is similar but desappeared from the market. Transfer was three 5-bit PWM (16-bit words).", 
            "title": "WS2801"
        }, 
        {
            "location": "/#apa102c-and-sk9822", 
            "text": "The APA102C and Sk9822 have SPI-like transfer, no timing constraint. New there is also a miniature APA102C-2020.\nThe APA102C is an additional control register v that sets the brightness of every pixel, independently of its color.\nAPA102 has 20 kHz PWM,  SK9822 1.2 kHz:", 
            "title": "APA102C and SK9822"
        }, 
        {
            "location": "/#1-wire-control-800-or-580-khz", 
            "text": "(timings see here)", 
            "title": "1-wire control   800 or 580 kHz"
        }, 
        {
            "location": "/#ws2812b", 
            "text": "The WS2812 (not shown) was the first RGB 5050 package with the microcontroller inside. 6-pin package replaced by WS2812b  The WS2812b is controlled by one wire with a critical timing that needs bit-banging routines on 16MHz AVR.", 
            "title": "WS2812b"
        }, 
        {
            "location": "/#apa104", 
            "text": "The APA104 has a slightly different timing than the WS2812B, but can be compatible. A 50us delay terminates the shift-in.", 
            "title": "APA104"
        }, 
        {
            "location": "/#apa106", 
            "text": "The  APA106 is the through-hole LED version of the APA104.", 
            "title": "APA106"
        }, 
        {
            "location": "/#sk6812", 
            "text": "The SK6812 receives 24 bit words. Transfer speed is 800 kHz.", 
            "title": "SK6812"
        }, 
        {
            "location": "/#a-word-about-serial-transfers", 
            "text": "Shift registers are used to convert a stream of bits synchronized by a clock into parallel data.\nA parallel register keeps the previous data during the shift and is updated at the end of the transfer.\nThis is the principle of the SPI transfer. Registers can be cascaded.   A popular application for this is to control LEDs. Several manufacturers propose shift registers with constant current sources at the outputs. A single resistor sets the current, same for all LEDs.\nPWM can be done on every LED. See  http://www.didel.com/diduino/CommandeLeds.pdf   for an elegant solution updating PWM while shifting.", 
            "title": "A word about serial transfers"
        }, 
        {
            "location": "/#ws2801-as-example-of-the-inside-logic", 
            "text": "The WS2801 includes a 24 bit shift register with three 8-bit PWM controllers. Three LEDs are controlled by the circuit, usually a RGB SMD LED in a 5050 package. Intensity of LEDs is controlled by a resistor, constant current circuitry makes the intensity independant of the voltage (with 3-5V range).   The block diagram show something new. Data is not shifted through the complete serially connected circuits. The first 24 bits stay in the first circuit. When 24 clocks are counted, a switch transfers the clock to the output. Since there is no load line to transfer the shifted data to the PWM circuit, a one-shot circuit is activated when there is no clock for more than 1 ms. The signals are regenerated, allowing long strips, but adding a delay.           As said before, each circuit takes the first set of clocks and data he receives for himself, not transmitting that information further. The next clocks and data are amplified and transmitted. The delay introduced between each LED may be noticed over very long strips. The APA102C implement an additional trick to make the transmission reliable. It results in a strange formula, incorrect and not explained for the terminating frame. Not easy to well understant if you have not been educated with integrated circuit logic. Let us try!               For the correct operation of a shift register, the flipflops must have the data stable when the clock edge occurs. set-up and hold time is 5 to 20 ns depending on the technology.The output D' changes after e.g. 20ns, and this must match the set-up time of the next flip-flop. One needs to add output buffers that introduce their own delay, plus the delay of the line. Depending on the difference between the clock and data propagation time, the transfer may not work correctly.  One solution is to increase the delay on the data line. This was probably done on the WS2801. It is more reliable to add a flip-flop on the data output, that add a delay of half a clock. This was implemented in the 1970' CD4094 8-bit shift register and is used on the APA102 and SK98.  The main advantage is the very high transfer speed it permits.       Due to the mechanism that allows to access the pixels in the order they have been sent, and not as if it was a simple shift register, data is delayed by half a clock for each consecutive pixel. The last bit sent for the last pixel must be pushed half a clock at a time till its destination.", 
            "title": "WS2801 as example of the inside logic"
        }, 
        {
            "location": "/#color-control", 
            "text": "Other chips have also 8-bit PWM, with a color order that may differ.", 
            "title": "Color control"
        }, 
        {
            "location": "/#rgb-leds-technology", 
            "text": "Discrete LED chips are soldered inside 5050 packages. It is not well documented what are the specifications and how the difference of LED intensity is compensated. In the best case, the information is:  Red 620-625nm 390-420mcd 2.0-2.2V Green 522-525nm 660-720mcd 3.0-3.4V Red 465-467nm 180-200mcd 3.0-3.4V", 
            "title": "RGB LEDs technology"
        }, 
        {
            "location": "/#rgb-vs-hsv", 
            "text": "RGB is not adequate for mixing colors. Using a \"rainbow\" variable (called hue) that goes through the rainbow colors is obtained from mixing RGB, as with the rather simple algorithm next from  this reference  we have reprogrammed in C (see appendix).  The  hue H  has a usually a 0-360 value due to its cylindrical representation. 0-255 is more convenient.  The  saturation S  says how the image is \"rich\" vs \"pale\" and will be kept at its maximum of 255.  The  value V  is the brightness 0-255.     Encoding colors is a rich and complex field. It is well described  here .", 
            "title": "RGB vs HSV"
        }, 
        {
            "location": "/#note-on-luminosity", 
            "text": "PWM is linear, 0 to 255. Our eye is not linear. 30% of PWM already feels as full light. \nNot convinced? Program intensity 0,16, 32\u2026 with a change every 0.2 seconds. The first steps are visible, not the last 5.\nThis means 16 or 32 intensity values are enough if converted to exponential values.   uint8_t talum[16] = {  0,5,11,18, 26,35,44,54, 64,76,90,110, 135,170,210,255};", 
            "title": "Note on luminosity"
        }, 
        {
            "location": "/#programming-existing-strips", 
            "text": "We are not concerned here about commercial products and their associated libraries.\nWe document how to program from the low level up, using simple portable C. Understanding how to initialize a port is the only requirement to use our libraries.", 
            "title": "Programming existing strips"
        }, 
        {
            "location": "/#ws2801apa102c-software", 
            "text": "These curcuits have a SPI-like transfer over 2-control lines. The max clock speed for the \nWS2801 and APA102C is 20 MHz and data set-up time is 30 ns. The order for the WS2801 depends on the wiring between the 14-pin circuit and the RGB LED.\nThe WS2801 restarts when there is no clock for 1ms. It is not documented if the transfer to the output latches is made when the register is filled or at restart.  The APA102 and SK9822 need a start frame of 32 clocks with null data. Then, for every pixel, 4 bytes in the order - intensity, blue, green, red. Finally, additional clocks are given as explained before. \nNo clock for 1ms transfers the data to the LED register, hence minimal clock rate is 1kHz, interrupts must be less than 1ms.\nAVR SPI can be used, with Ck on pin 13 and Data on pin 11. SS pin is not used, but that pin must be initialised as an output otherwise transmission does not happen. Byte transfer is 2us.\nShifting data out by software is slower (7us per byte) but any pin can be used. Using the shiftOut() Arduino function is no sense (slow and not easier).  These are two possible implementations of the Snd8() function.  Example 1:  //Spi.h\n#define bDa  3   // MOSI 11 only here\n#define bCk  5   // pin 13\n#define bLd  2   // SS pin 10 \n#define SpiControl 0b01010000\n// SPIE SPE DORD MSTR CPOL CPHA SPR1 SPR0\nvoid SetupSPI ()  {\n  DDRB |=  1 bCk | 1 bDa | 1 bLd ;\n  SPCR = SpiControl ;\n}\nvoid Snd8 (byte dd) {\n  SPDR = dd;\n  while (!(SPSR   1 SPIF)) {}\n}  Example 2:  \n//S2.h\n#define bCk  14 //PORTC\n#define bDa  15 \n#define DaOn  bitSet(PORTC,bDa)\n#define DaOff bitClear(PORTC,bDa)\n#define ClkPulse bitSet(PORTC,bDa); \\\n                 bitClear(PORTC,bDa)\nvoid SetupS2 () {\n  DDRC |= (1 bCk)+(1 bDa)\n}\nvoid Snd8 (byte dd) {\n  for (byte i=0;i 8;i++) {\n    if (dd   0x80) DaOn;\n    else DaOff; \n    CkPulse;   \n  }\n}  Note:  If  byte ,  bitSet ,  bitClear  is not accepted, add the line  #include Arduino.h .  In case of the APA102C, the requested transfer order is easily converted to a function. Pixel values can frequently be calculated during the transfer. If the pixel array is in a table, function is:  void SndRGB (byte n) {\n    Snd8(0x00); Snd8(0x00); Snd8(0x00); Snd8(0x00);\n    for (byte i=0;i NN;i++)  { Snd8(aa[i]); Snd8(gg[i]); Snd8(bb[i]); Snd8(rr[i]); }\n    for (byte i=0; i (NN+1)/2; i++) {CkOn; CkOff;} delay (10);\n}  If you give the correct number of clock pulses, only the declared LEDs will be activated.  See  https://github.com/nicoud/RgbLeds  for downloading the code.  You can find useful information on the APA102C on  https://www.pololu.com/product/2554  with comments on APA102C vs SK6812.", 
            "title": "WS2801/APA102C software"
        }, 
        {
            "location": "/#1-wire-smart-leds", 
            "text": "Saving one wire is not a real advantage, since it is slower and less reliable both on hardware and software side. These circuits have critical timing need need bit-banging assembler code or macros. Interrupts must be disables during transfers.     $Id: index.md,v 1.2 2017-01-03 15:02:22 obiwan Exp $", 
            "title": "1-wire smart LEDs"
        }
    ]
}